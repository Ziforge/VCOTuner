/*
  ==============================================================================

    OrnamentCrimeExporter.cpp
    Export calibration data in Ornament & Crime compatible formats

  ==============================================================================
*/

#include "OrnamentCrimeExporter.h"
#include <cmath>

bool OrnamentCrimeExporter::exportAsCHeader(const CalibrationTable& table,
                                            const File& outputFile,
                                            const String& arrayName,
                                            int channel)
{
    String header = generateCHeaderString(table, arrayName, channel);
    return outputFile.replaceWithText(header);
}

bool OrnamentCrimeExporter::exportAsReadable(const CalibrationTable& table,
                                              const File& outputFile)
{
    String readable = generateReadableString(table);
    return outputFile.replaceWithText(readable);
}

String OrnamentCrimeExporter::generateCHeaderString(const CalibrationTable& table,
                                                     const String& arrayName,
                                                     int channel)
{
    OCCalibrationData ocData = convertToOCFormat(table);
    ocData.channel = channel;

    String header;

    header += "/*\n";
    header += " * VCOTuner Calibration for Ornament & Crime\n";
    header += " * Generated: " + Time::getCurrentTime().toString(true, true) + "\n";
    header += " * Device: " + table.getDeviceName() + " (" + table.getDeviceBrand() + ")\n";
    header += " * Interface: " + table.getInterfaceName() + "\n";
    header += " *\n";
    header += " * Statistics:\n";
    header += " *   Max Error: " + String(table.getMaxErrorCents(), 2) + " cents\n";
    header += " *   Avg Error: " + String(table.getAverageErrorCents(), 2) + " cents\n";
    header += " */\n\n";

    header += "#ifndef OC_CUSTOM_CALIBRATION_H\n";
    header += "#define OC_CUSTOM_CALIBRATION_H\n\n";

    header += "// DAC calibration values for Channel " + String(char('A' + channel)) + "\n";
    header += "// Octave voltages: -3V, -2V, -1V, 0V, +1V, +2V, +3V, +4V, +5V, +6V, (upper bound)\n";
    header += "const uint16_t " + arrayName + "_dac_" + String(char('a' + channel)) + "[11] = {\n";

    for (int i = 0; i < 11; ++i)
    {
        float voltage = OC_MIN_VOLTAGE + i;
        if (i == 10) voltage = OC_MAX_VOLTAGE;  // Last point is +6V

        header += "    " + String(ocData.dacValues[i]);
        if (i < 10) header += ",";
        header += "   // " + String(voltage >= 0 ? "+" : "") + String(static_cast<int>(voltage)) + "V\n";
    }

    header += "};\n\n";
    header += "#endif // OC_CUSTOM_CALIBRATION_H\n";

    return header;
}

String OrnamentCrimeExporter::generateReadableString(const CalibrationTable& table)
{
    OCCalibrationData ocData = convertToOCFormat(table);

    String text;

    text += "Ornament & Crime Calibration Values\n";
    text += "====================================\n\n";
    text += "Device: " + table.getDeviceName() + " (" + table.getDeviceBrand() + ")\n";
    text += "Interface: " + table.getInterfaceName() + "\n";
    text += "Generated by VCOTuner: " + Time::getCurrentTime().toString(true, true) + "\n\n";

    text += "Statistics:\n";
    text += "  Max Error: " + String(table.getMaxErrorCents(), 2) + " cents\n";
    text += "  Avg Error: " + String(table.getAverageErrorCents(), 2) + " cents\n";
    text += "  RMS Error: " + String(table.getRMSErrorCents(), 2) + " cents\n\n";

    text += "DAC Calibration Values:\n";
    text += "-----------------------\n\n";

    text += "To enter these values in o_C calibration mode:\n";
    text += "1. Hold left encoder during boot to enter calibration\n";
    text += "2. For each voltage, adjust until the DAC value matches\n\n";

    for (int i = 0; i < 11; ++i)
    {
        float voltage = OC_MIN_VOLTAGE + i;
        if (i == 10) voltage = OC_MAX_VOLTAGE;

        String voltStr = String(voltage >= 0 ? "+" : "") + String(static_cast<int>(voltage)) + "V";
        float actualV = dacValueToVoltage(ocData.dacValues[i]);

        text += String(voltStr).paddedRight(' ', 5);
        text += "  DAC: " + String(ocData.dacValues[i]).paddedLeft(' ', 5);
        text += "  (actual: " + String(actualV, 4) + "V)\n";
    }

    text += "\nNote: These values are calculated to compensate for your\n";
    text += "VCO's tracking errors when driven by the o_C.\n";

    return text;
}

OrnamentCrimeExporter::OCCalibrationData OrnamentCrimeExporter::convertToOCFormat(const CalibrationTable& table)
{
    OCCalibrationData ocData;

    // For each octave point (-3V to +6V), find the corrected voltage
    // and convert to DAC value
    for (int i = 0; i < 11; ++i)
    {
        float targetVoltage = OC_MIN_VOLTAGE + i;
        if (i == 10) targetVoltage = OC_MAX_VOLTAGE;

        // Convert voltage to MIDI pitch (1V/Oct, 0V = C4 = MIDI 60)
        float midiPitch = 60.0f + targetVoltage * 12.0f;

        // Get corrected voltage from calibration table
        float correctedVoltage = table.getCorrectedVoltage(midiPitch);

        // Convert to DAC value
        ocData.dacValues[i] = voltageToDACValue(correctedVoltage);
    }

    return ocData;
}

CalibrationTable OrnamentCrimeExporter::importFromOCData(const OCCalibrationData& ocData)
{
    CalibrationTable table;

    for (int i = 0; i < 11; ++i)
    {
        float targetVoltage = OC_MIN_VOLTAGE + i;
        if (i == 10) targetVoltage = OC_MAX_VOLTAGE;

        float actualVoltage = dacValueToVoltage(ocData.dacValues[i]);

        // Convert to MIDI note
        int midiNote = 60 + static_cast<int>(targetVoltage * 12.0f);

        CalibrationTable::Entry entry;
        entry.midiNote = midiNote;
        entry.idealVoltage = targetVoltage;
        entry.actualVoltage = actualVoltage;
        entry.correctionOffset = actualVoltage - targetVoltage;
        entry.measuredFrequency = 440.0f * std::pow(2.0f, (midiNote - 69) / 12.0f);
        entry.errorCents = entry.correctionOffset * 12.0f * 100.0f;  // Approximate

        table.addEntry(entry);
    }

    return table;
}

uint16_t OrnamentCrimeExporter::voltageToDACValue(float voltage)
{
    // o_C DAC: 16-bit, -3V to +6V range
    // Linear mapping: -3V = 0, +6V = 65535
    float normalized = (voltage - OC_MIN_VOLTAGE) / (OC_MAX_VOLTAGE - OC_MIN_VOLTAGE);
    normalized = juce::jlimit(0.0f, 1.0f, normalized);
    return static_cast<uint16_t>(normalized * 65535.0f);
}

float OrnamentCrimeExporter::dacValueToVoltage(uint16_t dacValue)
{
    // Inverse of voltageToDACValue
    float normalized = static_cast<float>(dacValue) / 65535.0f;
    return OC_MIN_VOLTAGE + normalized * (OC_MAX_VOLTAGE - OC_MIN_VOLTAGE);
}

int OrnamentCrimeExporter::voltageToOctaveIndex(float voltage)
{
    // Which of the 11 calibration points is closest
    int index = static_cast<int>(std::round(voltage - OC_MIN_VOLTAGE));
    return juce::jlimit(0, 10, index);
}
